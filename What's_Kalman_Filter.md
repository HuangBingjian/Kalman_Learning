                                                  科普：什么是卡尔曼滤波

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（文章来源：http://bbs.loveuav.com/forum.php?mod=viewthread&tid=110）</center> 

1. 卡尔曼

&emsp;&emsp;在学习卡尔曼滤波器之前，首先看看为什么叫“卡尔曼”。跟其他著名的理论（例如傅立叶变换，泰勒级数等等）一样，卡尔曼也是一个人的名字，而跟他们
不同的是，他是个现代人！


&emsp;&emsp;卡尔曼全名Rudolf Emil Kalman，匈牙利数学家，1930年出生于匈牙利首都布达佩斯。1953，1954年于麻省理工学院分别获得电机工程学士及硕士学位。1957年于哥伦比亚大学获得博士学位。我们现在要学习的卡尔曼滤波器，正是源于他的博士论文和1960年发表的论文《A New Approach to Linear Filtering and Prediction Problems》（线性滤波与预测问题的新方法）。如果对这编论文有兴趣，可以到这里的地址下载：http://www.cs.unc.edu/~welch/kalman/media/pdf/Kalman1960.pdf


&emsp;&emsp;简单来说，卡尔曼滤波器是一个“optimal recursive data processing algorithm（最优化自回归数据处理算法）”。对于解决很大部分的问题，他是最优，效率最高甚至是最有用的。他的广泛应用已经超过30年，包括机器人导航，控制，传感器数据融合甚至在军事方面的雷达系统以及导弹追踪等等。近年来更被应用于计算机图像处理，例如头脸识别，图像分割，图像边缘检测等等。

------
2．卡尔曼滤波器的介绍
（Introduction to the Kalman Filter）


&emsp;&emsp;为了可以更加容易的理解卡尔曼滤波器，这里会应用形象的描述方法来讲解，而不是像大多数参考书那样罗列一大堆的数学公式和数学符号。但是，他的5条公式是其核心内容。结合现代的计算机，其实卡尔曼的程序相当的简单，只要你理解了他的那5条公式。


&emsp;&emsp;在介绍他的5条公式之前，先让我们来根据下面的例子一步一步的探索。


&emsp;&emsp;假设我们要研究的对象是一个房间的温度。根据你的经验判断，这个房间的温度是恒定的，也就是下一分钟的温度等于现在这一分钟的温度（假设我们用一分钟来做时间单位）。假设你对你的经验不是100%的相信，可能会有上下偏差几度。我们把这些偏差看成是高斯白噪声（White Gaussian Noise），也就是这些偏差跟前后时间是没有关系的而且符合高斯分配（Gaussian Distribution）。另外，我们在房间里放一个温度计，但是这个温度计也不准确的，测量值会比实际值偏差。我们也把这些偏差看成是高斯白噪声。


&emsp;&emsp;好了，现在对于某一分钟我们有两个有关于该房间的温度值：你根据经验的预测值（系统的预测值）和温度计的值（测量值）。下面我们要用这两个值结合他们各自的噪声来估算出房间的实际温度值。


&emsp;&emsp;假如我们要估算k时刻的是实际温度值。首先你要根据k-1时刻的温度值，来预测k时刻的温度。因为你相信温度是恒定的，所以你会得到k时刻的温度预测值是跟k-1时刻一样的，假设是23度，同时该值的高斯噪声的偏差是5度（5是这样得到的：如果k-1时刻估算出的最优温度值的偏差是3，你对自己预测的不确定度是4度，他们平方相加再开方，就是5）。然后，你从温度计那里得到了k时刻的温度值，假设是25度，同时该值的偏差是4度。


&emsp;&emsp;由于我们用于估算k时刻的实际温度有两个温度值，分别是23度和25度。究竟实际温度是多少呢？相信自己还是相信温度计呢？究竟相信谁多一点，我们可以用他们的covariance来判断。因为Kg^2=5^2/(5^2+4^2)，所以Kg=0.78，我们可以估算出k时刻的实际温度值是：23+0.78*(25-23)=24.56度。可以看出，因为温度计的covariance比较小（比较相信温度计），所以估算出的最优温度值偏向温度计的值。


&emsp;&emsp;现在我们已经得到k时刻的最优温度值了，下一步就是要进入k+1时刻，进行新的最优估算。到现在为止，好像还没看到什么自回归的东西出现。对了，在进入k+1时刻之前，我们还要算出k时刻那个最优值（24.56度）的偏差。算法如下：((1-Kg)*5^2)^0.5=2.35。这里的5就是上面的k时刻你预测的那个23度温度值的偏差，得出的2.35就是进入k+1时刻以后k时刻估算出的最优温度值的偏差（对应于上面的3）。


&emsp;&emsp;就是这样，卡尔曼滤波器就不断的把covariance递归，从而估算出最优的温度值。他运行的很快，而且它只保留了上一时刻的covariance。上面的Kg，就是卡尔曼增益（Kalman Gain）。他可以随不同的时刻而改变他自己的值，是不是很神奇！


&emsp;&emsp;下面就要言归正传，讨论真正工程系统上的卡尔曼。

------
3． 卡尔曼滤波器算法
（The Kalman Filter Algorithm）


&emsp;&emsp;在这一部分，我们就来描述源于Dr Kalman 的卡尔曼滤波器。下面的描述，会涉及一些基本的概念知识，包括概率（Probability），随即变量（Random Variable），高斯或正态分配（Gaussian Distribution）还有State-space Model等等。但对于卡尔曼滤波器的详细证明，这里不能一一描述。


&emsp;&emsp;首先，我们先要引入一个离散控制过程的系统。该系统可用一个线性随机微分方程（Linear Stochastic Difference equation）来描述：

>                                               X(k)=A X(k-1)+B U(k)+W(k) 

&emsp;&emsp;再加上系统的测量值：

>                                               Z(k)=H X(k)+V(k) 

&emsp;&emsp;上两式子中，X(k)是k时刻的系统状态，U(k)是k时刻对系统的控制量。A和B是系统参数，对于多模型系统，他们为矩阵。Z(k)是k时刻的测量值，H是测量系统的参数，对于多测量系统，H为矩阵。W(k)和V(k)分别表示过程和测量的噪声。他们被假设成高斯白噪声(White Gaussian Noise)，他们的covariance 分别是Q，R（这里我们假设他们不随系统状态变化而变化）。


&emsp;&emsp;对于满足上面的条件(线性随机微分系统，过程和测量都是高斯白噪声)，卡尔曼滤波器是最优的信息处理器。下面我们来用他们结合他们的covariances 来估算系统的最优化输出（类似上一节那个温度的例子）。


&emsp;&emsp;首先我们要利用系统的过程模型，来预测下一状态的系统。假设现在的系统状态是k，根据系统的模型，可以基于系统的上一状态而预测出现在状态：

>                                               X(k|k-1)=A X(k-1|k-1)+B U(k) ……….. (1)

&emsp;&emsp;式(1)中，X(k|k-1)是利用上一状态预测的结果，X(k-1|k-1)是上一状态最优的结果，U(k)为现在状态的控制量，如果没有控制量，它可以为0。


&emsp;&emsp;到现在为止，我们的系统结果已经更新了，可是，对应于X(k|k-1)的covariance还没更新。我们用P表示covariance：

>                                               P(k|k-1)=A P(k-1|k-1) A’+Q ……… (2)

&emsp;&emsp;式(2)中，P(k|k-1)是X(k|k-1)对应的covariance，P(k-1|k-1)是X(k-1|k-1)对应的covariance，A’表示A的转置矩阵，Q是系统过程的covariance。式子1，2就是卡尔曼滤波器5个公式当中的前两个，也就是对系统的预测。


&emsp;&emsp;现在我们有了现在状态的预测结果，然后我们再收集现在状态的测量值。结合预测值和测量值，我们可以得到现在状态(k)的最优化估算值X(k|k)：


>                                               X(k|k)= X(k|k-1)+Kg(k) (Z(k)-H X(k|k-1)) ……… (3)


&emsp;&emsp;其中Kg为卡尔曼增益(Kalman Gain)：


>                                               Kg(k)= P(k|k-1) H’ / (H P(k|k-1) H’ + R) ……… (4)


&emsp;&emsp;到现在为止，我们已经得到了k状态下最优的估算值X(k|k)。但是为了要另卡尔曼滤波器不断的运行下去直到系统过程结束，我们还要更新k状态下X(k|k)的covariance：


>                                               P(k|k)=（I-Kg(k) H）P(k|k-1) ……… (5)


&emsp;&emsp;其中I 为1的矩阵，对于单模型单测量，I=1。当系统进入k+1状态时，P(k|k)就是式子(2)的P(k-1|k-1)。这样，算法就可以自回归的运算下去。


&emsp;&emsp;卡尔曼滤波器的原理基本描述了，式子1，2，3，4和5就是他的5 个基本公式。根据这5个公式，可以很容易的实现计算机的程序。


&emsp;&emsp;下面，我会用程序举一个实际运行的例子。。。


4． 简单例子
（A Simple Example）


&emsp;&emsp;这里我们结合第二第三节，举一个非常简单的例子来说明卡尔曼滤波器的工作过程。所举的例子是进一步描述第二节的例子，而且还会配以程序模拟结果。


&emsp;&emsp;根据第二节的描述，把房间看成一个系统，然后对这个系统建模。当然，我们见的模型不需要非常地精确。我们所知道的这个房间的温度是跟前一时刻的温度相同的，所以A=1。没有控制量，所以U(k)=0。因此得出：


>                                               X(k|k-1)=X(k-1|k-1) ……….. (6)


&emsp;&emsp;式子（2）可以改成：


>                                               P(k|k-1)=P(k-1|k-1) +Q ……… (7)


&emsp;&emsp;因为测量的值是温度计的，跟温度直接对应，所以H=1。式子3，4，5可以改成以下：


>                                               X(k|k)= X(k|k-1)+Kg(k) (Z(k)-X(k|k-1)) ……… (8)


>                                               Kg(k)= P(k|k-1) / (P(k|k-1) + R) ……… (9)


>                                               P(k|k)=（1-Kg(k)）P(k|k-1) ……… (10)


&emsp;&emsp;现在我们模拟一组测量值作为输入。假设房间的真实温度为25度，我模拟了200个测量值，这些测量值的平均值为25度，但是加入了标准偏差为几度的高斯白噪声（在图中为蓝线）。


&emsp;&emsp;为了令卡尔曼滤波器开始工作，我们需要告诉卡尔曼两个零时刻的初始值，是X(0|0)和P(0|0)。他们的值不用太在意，随便给一个就可以了，因为随着卡尔曼的工作，X会逐渐的收敛。但是对于P，一般不要取0，因为这样可能会令卡尔曼完全相信你给定的X(0|0)是系统最优的，从而使算法不能收敛。我选了X(0|0)=1度，P(0|0)=10。


&emsp;&emsp;该系统的真实温度为25度，图中用黑线表示。图中红线是卡尔曼滤波器输出的最优化结果（该结果在算法中设置了Q=1e-6，R=1e-1）。

------

&emsp;&emsp;附matlab下面的kalman滤波程序：（这里贴我自己的代码^_^）
&emsp;&emsp;https://blog.csdn.net/u013165921/article/details/78328230

    % Kalman滤波技术

    A=1;                                        % 状态转移矩阵 Φ(k)
    H=0.2;                                      % 观测矩阵 H(k)
    X(1)=0;                                     % 目标的状态向量 X(k)
    % V(1)=0;                                   % 过程噪声 V(k)
    Y(1)=1;                                     % 一步预测x(k)的更新 X(k+1|k+1)
    P(1)=10;                                    % 一步预测的协方差 P(k)
    N=200;
    V=randn(1,N);                               % 模拟产生过程噪声(高斯分布的随机噪声)
    w=randn(1,N);                               % 模拟产生测量噪声

    for k=2:N

        X(k) = A * X(k-1)+V(k-1);               % 状态方程:X(k+1)=Φ(k)X(k)+G(k)V(k),其中G(k)=1

    end

    Q=std(V)^2;                                 % W(k)的协方差,std()函数用于计算标准偏差  
    R=std(w)^2;                                 % V(k)的协方差 covariance

    Z=H*X+w;                                    % 观测方程:Z(k+1)=H(k+1)X(k+1)+W(k+1),Z(k+1)是k+1时刻的观测值

    for t=2:N

        P(t) = A * P(t-1)+Q;                    % 一步预测的协方差 P(k+1|k)   

        S(t) = H.^2 * P(t)+R;                   % 观测向量的预测误差协方差 S(k+1)

        K(t) = H * P(t)/S(t);                   % 卡尔曼滤波器增益 K(k+1) 

        v(t) = Z(t) - ( A * H * Y(t-1) );       % 新息/量测残差 v(k+1)

        Y(t)=A * Y(t-1) + K(t) * v(t);          % 状态更新方程 X(k+1|k+1)=X(k+1|k)+K(k+1)*v(k+1)

        P(t)=(1-H * K(t)) * P(t);               % 误差协方差的更新方程: P(k+1|k+1)=(I-K(k+1)*H(k+1))*P(k+1|k)
    end


    t=1:N;
    plot(t,Y,'r',t,Z,'g',t,X,'b');              % 红色线最优化估算结果滤波后的值，%绿色线观测值，蓝色线预测值
    legend('Kalman滤波结果','观测值','预测值');

![image](https://github.com/HuangBingjian/Kalman_Learning/blob/master/figure/kalman_learning_1.png)
![image](https://github.com/HuangBingjian/Kalman_Learning/blob/master/figure/kalman_learning_2.png)
